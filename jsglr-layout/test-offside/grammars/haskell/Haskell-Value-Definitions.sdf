module Haskell-Value-Definitions
exports
  context-free syntax
    Valdef 		   -> Decl
    FunLHS "=" Exp MaybeWhere -> Valdef 	{cons("Valdef"), longest-match}

    FunLHS Gdrh+ MaybeWhere  -> Valdef 	{cons("GdValdef"), longest-match}
    "|" Exp "=" Exp 	   -> Gdrh   	{cons("Guarded")}   

    
    Pat -> FunLHS
    Var APat+ -> FunLHS {cons("VarFunLHS")}
    Pat Varop Pat -> FunLHS {cons("OpFunLHS")}
    "(" FunLHS ")" APat+ -> FunLHS {cons("NestedFunLHS")}

  context-free syntax
    "where" DeclList       -> Where     {cons("Where")}
    
    -> MaybeWhere {ast("Where(DeclList(Empty))")}
    Where   -> MaybeWhere
  
    DeclList 		   -> Declbinds


  context-free restrictions
%%  	NoWhere -/- [w].[h].[e].[r].[e]

  context-free syntax
  	NoOffsideDeclBlock -> DeclList {cons("DeclList")}
  	OffsideDeclList | Empty   -> DeclList {cons("DeclList")}
  	
    "{" NoOffsideDeclList | Empty "}"  -> NoOffsideDeclBlock {bracket, ignore-indent}
    
  context-free priorities
    Decl -> NoOffsideDecl
  >
    NoOffsideDecl ";" -> NoOffsideDecl {prefer}
  >
    ";" NoOffsideDecl -> NoOffsideDecl

  context-free syntax
    NoOffsideDecl -> NoOffsideDeclList
    NoOffsideDecl ";" NoOffsideDeclList -> NoOffsideDeclList {cons("DeclSeq")}


  context-free priorities
    Decl -> OffsideDecl {layout(gt(col(left(1)), col(first(1))))}
  >
    OffsideDecl ";" -> OffsideDecl {prefer, layout(gt(col(first(2)), col(first(1))))}
  >
    ";" OffsideDecl -> OffsideDecl {layout(gt(col(first(2)), col(first(1))))}
  >
    Decl ";" OffsideDecl -> OffsideDecl
          {cons("DeclSeq"),
           layout(and(gt(col(left(1)), col(first(1))),
                  and(gt(col(first(2)), col(first(1))),
                      gt(col(first(3)), col(first(1))))))}
  
  context-free syntax
    OffsideDecl -> OffsideDeclList
    OffsideDeclNEWLINE OffsideDeclList -> OffsideDeclList {cons("DeclSeq"), layout(eq(col(first(1)), col(first(2))))}

    OffsideDecl LAYOUT? -> OffsideDeclNEWLINE {enforce-newline}