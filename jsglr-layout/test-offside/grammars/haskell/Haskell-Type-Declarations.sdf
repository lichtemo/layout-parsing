module Haskell-Type-Declarations
exports
  context-free syntax
    "type" Type "=" CType	  -> Topdecl {cons("TypeDecl")}
    "data" Context? Type "=" Constrs Deriving 	  -> Decl {cons("Data")}
    "newtype" Context? Type "=" Newconstr Deriving -> Decl {cons("NewTypeDecl")}

  context-free syntax
    "deriving" Qtycls 		     	-> Deriving {cons("Derive")}
    "deriving" "(" ")" 		     	-> Deriving {cons("NoDeriving")}
    "deriving" "(" {Qtycls ","}+ ")" 	-> Deriving {cons("Derive")}
    				     	-> Deriving {cons("NoDeriving")}
  context-free syntax
    {Constr "|"}+                        -> Constrs

    Conid Satype*       -> Constr {cons("ConstrDecl")}
    Sbtype Conop Sbtype -> Constr {cons("InfixConstr")}

    Conid Type 			 	 -> Newconstr
    Conid LabeledConstr 	 -> Newconstr
    "{" Var "::" Type "}" -> LabeledConstr {cons("LabeledConstr"), ignore-layout}
   
    AType 				 -> Satype
    "!" AType 				 -> Satype
    CType     				 -> Sbtype
    "!" CType 				 -> Sbtype
 
