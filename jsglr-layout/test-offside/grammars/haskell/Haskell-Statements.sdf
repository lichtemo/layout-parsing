module Haskell-Statements

imports
	Haskell-Identifier-Sorts
	Haskell-Expressions
	Haskell-Operators

exports
  context-free syntax
    Pat LeftArrowOp Exp 	-> Stmt 	{ast("BindStmt(<1>,<3>)")}
    Exp               	-> Stmt 	{cons("ExpStmt")}
    "let" Declbinds   	-> Stmt 	{cons("LetStmt")}
    Qvar "=" Exp 	-> Fbind	{cons("FBind")}

  context-free syntax
  	NoOffsideStmtBlock -> StmtList {cons("StmtList")}
  	OffsideStmtList   -> StmtList {cons("StmtList")}
  	
    "{" NoOffsideStmtListSem "}"  -> NoOffsideStmtBlock {bracket, ignore-layout}

  context-free priorities
    Stmt -> NoOffsideStmt
  >
    NoOffsideStmt ";" -> NoOffsideStmt

  context-free syntax
    NoOffsideStmt -> NoOffsideStmtList
    NoOffsideStmt ";" NoOffsideStmtList -> NoOffsideStmtList {cons("StmtSeq")}

    NoOffsideStmtList  -> NoOffsideStmtListSem
    ";" NoOffsideStmtListSem -> NoOffsideStmtListSem 


  context-free priorities
   { Stmt -> OffsideStmt {layout("1.first.col < 1.left.col")}
   	 LayIfThenElse -> OffsideStmt {cons("ExpStmt"), avoid}
   }
  >
    OffsideStmt ";" -> OffsideStmt {layout("1.first.col < 2.first.col")}
  >
    ";" OffsideStmt -> OffsideStmt {layout("1.first.col < 2.first.col")}
  >
    OffsideStmt ";" Stmt -> OffsideStmt
          {cons("StmtSeq"),
           layout("1.first.col < 2.first.col && 1.first.col < 3.first.col && 1.first.col < 3.left.col")}
  
  context-free syntax
    OffsideStmt -> OffsideStmtList
    OffsideStmtNEWLINE OffsideStmtList -> OffsideStmtList {cons("StmtSeq"), layout("1.first.col == 2.first.col")}

    OffsideStmt LAYOUT? -> OffsideStmtNEWLINE {enforce-newline}
