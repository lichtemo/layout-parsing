module GHC-TypeFamilies

	imports GHC-EqualityConstraints
	imports GHC-KindSignature
	imports Haskell-Syntax

	exports
	
		context-free syntax
		
			"type" "family" Type OptKindSig	-> Decl {cons("TypeFamily")}
			"data" "family" Type OptKindSig	-> Decl {cons("DataFamily")}
%%			"data" Type "=" CType	  		-> Decl {cons("DataDecl"), avoid}
%%			"data" Type "=" CType	  		-> Topdecl {reject}
			"type" Type OptKindSig			-> Decl {cons("TypeFamily")}
			"data" Type OptKindSig			-> Decl {cons("DataFamily")}
			"type" Type "=" CType	  		-> Decl {cons("TypeDecl"), avoid}
			"type" "instance" Type "=" CType -> Decl {cons("TypeInstDecl")}
			"data" "instance" Context? Type "=" Constrs Deriving  -> Decl {cons("DataInstDecl")}
			"newtype" "instance" Context? Type "=" Constrs Deriving  -> Decl {cons("NewTypeInstDecl")}
		lexical syntax
			"family" -> ReservedId
		
		lexical restrictions
			"family" -/- [a-zA-Z0-9\'\_]