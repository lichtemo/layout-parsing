module Haskell-Expressions
exports   
  context-free syntax
    Exp 				 -> AnyExp

    Qvar 				 -> Exp 	{cons("Var")}
    Gcon 				 -> Exp 	{cons("Constr")}
    Literal 				 -> Exp 	{cons("Lit")}
    "(" Exps2 ")" 			 -> Exp 	{cons("Product")}
%%    "(#" Exps "#)" 			 -> Exp 	{cons("Unboxed?")}
    "(" Exp ")" 			 -> Exp 	{bracket}

    {Exp ","}+ 				 -> Exps
    Exp "," {Exp ","}+ 			 -> Exps2 	{cons("Cons")}
    APat+				 -> Fargs


  context-free syntax
    "infix"  	   	  -> Infix 	{cons("Infix")}
    "infixl" 	   	  -> Infix 	{cons("InfixL")}
    "infixr" 	   	  -> Infix 	{cons("InfixR")}
    INTEGER? 	   	  -> Prec
    {Op ","}+ 	   	  -> Ops
    Infix Prec Ops 	  -> Fixdecl 	{cons("FixDecl")}
    Fixdecl 	   	  -> Decl 

    "(" Exp Qop ")"  -> Exp 	{cons("LSection")}
    "(" QopNoNeg Exp ")" -> Exp 	{cons("RSection")}

    Qop -> QopNoNeg    
    "-" -> QopNoNeg {reject}
 
    "{" {Fbind ","}* "}" -> LabelBinds {cons("LabelBinds"), ignore-indent}

  context-free priorities
    Qvar "@" Exp 			  -> Exp  	{cons("Named")}
  > Exp LabelBinds 			  -> Exp  	{cons("Labeled")}
  > Exp				  	  -> Aexp
  > Exp Exp				  -> Exp 	{cons("AppBin"),left}
  > Exp "::" Type 			  -> Exp 	{cons("Typed")}
  > "-" Exp               -> Exp  {cons("Negation")}
  > Exp Qop Exp -> Exp {cons("OpApp"), right}


  context-free syntax
  	"\\" Fargs "->" Exp		  -> Exp 	{cons("Abs")}
    "let" Declbinds "in" Exp 		  -> Exp 	{cons("Let")} 
    "if" AnyExp "then" AnyExp "else" Exp -> Exp 	{cons("If")}
    "do" StmtList -> Exp {cons("Do"), longest-match}
    "case" AnyExp "of" AltList          -> Exp  	{cons("Case"), longest-match}

  context-free priorities
  	Exp Exp				  -> Exp 	{cons("AppBin"),left}
  	> {
        "\\" Fargs "->" Exp -> Exp
       "let" Declbinds "in" Exp -> Exp 
       "if" AnyExp "then" AnyExp "else" Exp -> Exp
       "case" AnyExp "of" AltList -> Exp
       "do" StmtList -> Exp
      }

  context-free priorities
    Exp Qop Exp -> Exp
  <0>
  > {
  	 "\\" Fargs "->" Exp -> Exp
     "let" Declbinds "in" Exp -> Exp 
     "if" AnyExp "then" AnyExp "else" Exp -> Exp
    }
 
  context-free priorities
  	"-" Exp               -> Exp  {cons("Negation")}
    >
  	Exp Qop Exp -> Exp
  
  
  
%% Notes:
%% AnyExp is used to prevent priorities from forbidding expressions
%% where the do not cause ambiguities.
%% Fargs is used instead of Aexp+ because of a bug in the SDF2 
%% normalizer; regular expression expansion does not take into
%% account symbols used only in priority rules.

