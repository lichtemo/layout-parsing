module GHC-FlexibleContexts

imports
	Haskell-Identifier-Sorts
	Haskell-Types

exports
	context-free syntax
		
	%% Contexts are allows to be arbitrary types and not only classes
	%%	Type "=>" -> Context {cons("FlexContext")}
	%%	Vars "::" FlexibleContext? Type -> Signdecl {cons("FlexSignDecl")}
	%%	Vars "::" Context? Type 		-> Signdecl {cons("FlexSignDecl"), avoid}
		
	%% Class declarations may have a FlexibleContext instead of a SContext (Simple Context)
	%% (The bounds is that the superclasses are acylic, but this is not part of the parser)
	%% The rules are not needd because the FlexibleContext may be produces to an SContext
	%%	"class" FlexibleContext? Tycls Tyvar MaybeWhere 	-> Topdecl {cons("FlexibleClass")}
	%%	"class" SContext? Tycls Tyvar MaybeWhere 			-> Topdecl {cons("FlexibleClass"), avoid}
	
	%% Also Instances may have flexible contexts
	%% We do not use Inst but Type.
	%% Inst is given in the Haskell Report but Type in the GHC sources
	
	%%	Inst* 		-> InstanceType
		AType* 		-> InstanceType {avoid}
		
		Qtycls InstanceType 	-> InstanceSig {cons("InstanceSig")}
		"(" InstanceSig ")"		-> InstanceSig {bracket}
		
		"instance" SContext? InstanceSig MaybeWhere 				-> Topdecl {cons("FlexibleInstance"), avoid}
	
	%% Definition of the Flexible Classes
	%%	Qtycls "(" Type ")" 	-> FlexibleClass {cons("Class")}
    %%	Qtycls Gtycon 			-> FlexibleClass {cons("Class")}
    %%	Qtycls Tyvar 			-> FlexibleClass {cons("SimpleClass")}
    %%	"(" FlexibleClass ")"	-> FlexibleClass {bracket}
    Type -> FlexibleClass {cons("FlexibleClass")}
    
    %% Definition of the Flexible Content
    
    	FlexibleClass "=>" 										-> FlexibleContext {cons("FlexibleContext")}
    	%%"(" FlexibleClass "," {FlexibleClass ","}+ ")" "=>" 	-> FlexibleContext {cons("FlexibleContext")}
    
    	FlexibleContext -> SContext {avoid}
    	FlexibleContext -> Context {avoid}	