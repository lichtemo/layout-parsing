module GHC-FlexibleContexts

exports
	context-free syntax
		
	%% Contexts are allows to be arbitrary types and not only classes
	%%	Type "=>" -> Context {cons("FlexContext")}
		Vars "::" FlexibleContext? Type -> Signdecl {cons("FlexSignDecl")}
		Vars "::" Context? Type 		-> Signdecl {cons("FlexSignDecl"), avoid}
		
	%% Class declarations may have a FlexibleContext instead of a SContext (Simple Context)
	%% (The bounds is that the superclasses are acylic, but this is not part of the parser)
		"class" FlexibleContext? Tycls Tyvar MaybeWhere 	-> Topdecl {cons("FlexibleClass")}
		"class" SContext? Tycls Tyvar MaybeWhere 			-> Topdecl {cons("FlexibleClass"), avoid}
	
	%% Also Instances may have flexible contexts
	%% We do not use Inst but Type.
	%% Inst is given in the Haskell Report but Type in the GHC sources
	
		Inst* 		-> InstanceType
		AType* 		-> InstanceType {avoid}
		
		Qtycls InstanceType 	-> InstanceSig
		"(" InstanceSig ")"		-> InstanceSig
		
		"instance" FlexibleContext InstanceSig MaybeWhere 				-> Topdecl {cons("FlexibleInstance")}
		"instance" SContext? InstanceSig MaybeWhere 					-> Topdecl {cons("FlexibleInstance"), avoid}
	
	%%	"instance" FlexibleContext? "(" Qtycls InstanceType ")" MaybeWhere		-> Topdecl {cons("FlexibleInstance")}
	%%	"instance" SContext? "(" Qtycls InstanceType ")" MaybeWhere    		-> Topdecl {cons("FlexibleInstance"), avoid}
	
	
	%% Definition of the Flexible Classes
		Qtycls "(" Type ")" 	-> FlexibleClass {cons("Class")}
    	Qtycls Gtycon 			-> FlexibleClass {cons("Class")}
    	Qtycls Tyvar 			-> FlexibleClass {cons("SimpleClass")}
    	"(" FlexibleClass ")"	-> FlexibleClass
    
    %% Definition of the Flexible Content
    
    	FlexibleClass "=>" 										-> FlexibleContext {cons("FlexibleContext")}
    	"(" FlexibleClass "," {FlexibleClass ","}+ ")" "=>" 	-> FlexibleContext {cons("FlexibleContext")}
    
    	FlexibleContext -> SContext {reject}
    	FlexibleContext -> Context {reject}	