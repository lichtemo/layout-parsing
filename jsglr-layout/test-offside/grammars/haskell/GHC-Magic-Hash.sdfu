module GHC-Magic-Hash
imports Haskell-Identifiers
imports Haskell-Numbers
imports Haskell-Strings
exports
  lexical syntax
    LowerCase AnyLetter*[\#]+		-> VARID {longest-match}
	[\_] AnyLetter+	[\#]+			-> VARID {longest-match}
	UpperCase AnyLetter*[\#]+		-> CONID {longest-match}
  
  %% These restrictions are not ok, for UnboxedTuples eg (#a,b#), where b is not a magic hash, but there is the longest match
   lexical restrictions
    VARID -/- [\#] . ~[\)]
  	CONID -/- [\#] . ~[\)]
  	
  syntax
  %%	<"("-LEX> <LAYOUT?-CF> <Exp-CF> <"#"-LEX> <")"-LEX> -> <Exp-CF> {reject}

	context-free syntax
	%% "#" -> Qop {reject}
	%%"(" Exp Qop ")" -> Exp {cons("LSection"), avoid}

  lexical syntax
    Decimal              -> INTEGER-HASH
    [0] [Oo] Octal       -> INTEGER-HASH
    [0] [Xx] Hexadecimal -> INTEGER-HASH
    
    Decimal "." Decimal           -> FLOAT-HASH
    Decimal Exponent              -> RATIONAL-HASH
    Decimal "." Decimal Exponent  -> RATIONAL-HASH

  syntax
    "'" CharChar "'" "#"       -> <Char-HASH-CF> {cons("CharHash")}
    "\"" StringChar* "\"" "#"  -> <String-HASH-CF> {cons("StringHash")}
    <INTEGER-HASH-LEX> "#" -> <Integer-HASH-CF> {cons("IntegerHash")}
    <FLOAT-HASH-LEX> "#" -> <Float-HASH-CF> {cons("FloatHash")}
    <RATIONAL-HASH-LEX> "#" -> <Float-HASH-CF> {cons("FloatHash")}
    
  context-free syntax
    Char-HASH   -> Literal
    String-HASH -> Literal
    Integer-HASH  -> Literal
    Float-HASH    -> Literal
   
  %% For the same reason, these are follow restrictions are wrong
  %% There we do not need a longest match because only one # is allowed
  lexical restrictions
    INTEGER -/- [\#]. ~[\)]
    FLOAT -/- [\#]. ~[\)]
    RATIONAL -/- [\#]. ~[\)]
    
  context-free restrictions
    Char -/- [\#]. ~[\)]
    String -/- [\#]. ~[\)]
  
  
